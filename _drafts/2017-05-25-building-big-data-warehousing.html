---
layout: post
title: Building Big Data Warehousing
date: '2017-05-25T05:08:00.000-07:00'
author: Karteek Yadavilli
tags: 
modified_time: '2017-05-25T05:08:43.301-07:00'
blogger_id: tag:blogger.com,1999:blog-8004810643159823472.post-5739126739217533058
blogger_orig_url: http://www.akyadavilli.xyz/2017/05/building-big-data-warehousing.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">This post is intended to explain Big Data Warehouse implementation by leveraging the best concepts of Data Warehousing and leveraging the big data technologies for the same.<br />Some of the key concepts we will learn are these:<br />1) How to perform Slowly changing dimensions using PySpark and Hive?<br />2) How to implement Data Lake based MDM?<br /><br />Before we get there, let us examine, the definition of slowly changing dimensions and the different types that there are:<br /><br />The type 0 method is to leave the attributes unchanged. This will lose no information as long as the attributes are for unchanging properties, such as an employee’s date of birth. For these attributes, historical data is not an issue.<br /><br />The type 1 method is to overwrite all changes to dimension attributes. For tables for which historical data is not required, this is the typical way updates are carried out. Here, again, historical data is not an issue.<br /><br />The type 2 method is to create a new row every time there is a change to any attribute in a dimension. The after-update row is then distinguished from the before-update row by means of a date or timestamp on one or both rows. This method uses the first of Kimball and Ross’ SCD types that addresses the issue of keeping track of historical data.<br /><br />The type 3 method is to add a new column for each attribute for which we want to keep both the current value and the previous value (or perhaps the current value and the original value, but, in any case, only one value other than the current value). This will normally result in using less storage than a type 2 SCD will use, for the same amount of information, and indeed there appears to be no other reason to choose a type 3 over a type 2.<br /><br />The type 4 method is to vertically partition a dimension into a “base dimension,” for which updates will be handled as overwrites, and a separate “mini-dimension,” for which updates will be handled as a type 2 SCD. This means that the technique of making a full copy of a row and applying an update to the new copy will be applied to rows with fewer columns, and will thus use less storage than a type 2 SCD for which each update requires a copy of the entire row.<br /><br />The type 5 method also splits a dimension into a base dimension table and a mini-dimension table. But in each base dimension row, it adds a foreign key to the row in the base dimension to point to the row in the mini-dimension, which contains the most current values for those mini-dimension attributes. Kimball and Ross call this method “add(ing) mini-dimension and type 1 outrigger”.<br /><br />The type 6 method is to include all mini-dimension columns in the base table, and to overwrite the values for those columns, in the base table, every time there is an update. The mini-dimension then keeps the history of changes to the values in those columns, and the base dimension keeps the current values for those columns. This eliminates a join from the base dimension to the mini-dimension which would otherwise be required to retrieve the current values for all columns in the complete dimension.<br /><br />The type 7 method combines a type 1 SCD that records current data, and a type 2 SCD that records a history of changes.</div>